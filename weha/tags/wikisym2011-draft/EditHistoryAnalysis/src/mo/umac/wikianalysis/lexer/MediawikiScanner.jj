options{	STATIC = false;	UNICODE_INPUT = true;}PARSER_BEGIN(MediawikiScanner)package mo.umac.wikianalysis.lexer;import java.io.*;import java.util.*;public class MediawikiScanner{	public ArrayList < WikiToken > tokens;	public static void main(String [] args) throws ParseException, TokenMgrError	{		try		{			Reader in = new InputStreamReader(new FileInputStream("/home/peter/Desktop/Examples/newText.txt"), "UTF-8");			BufferedReader oldFile = new BufferedReader(in);			MediawikiScanner parser = new MediawikiScanner(oldFile);			parser.tokens = new ArrayList < WikiToken > ();			parser.parse();			System.out.println(parser.tokens);			oldFile.close();		}		catch (FileNotFoundException e)		{			// TODO Auto-generated catch block
			e.printStackTrace();		}		catch (IOException e)		{			// TODO Auto-generated catch block
			e.printStackTrace();		}	}	public void parse() throws ParseException	{		doParse();	}	public WikiToken [] getTokens()	{		WikiToken [] a = new WikiToken [tokens.size()];		tokens.toArray(a);		return a;	}}PARSER_END(MediawikiScanner)TOKEN_MGR_DECLS :{	int prevLexState;}<* >TOKEN :{	< #NEW_LINE :		"\r\n"	|	"\r"	|	"\n" >|	< #SPACE : [ " ", "\t" ] >	// All special symbols from the range 0-127
|	< #SPECIAL_SYMBOL : [ "!", "\"", "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", ":", ";", "<", "=", ">", "?", "@", "\\", "^", "_", "`", "{", "|", "}", "~" ] >	// Characters are defined as all possible symbols excluding special 
	// symbols, spaces and new lines
|	< #CHAR : ~[ "\t", "\n", "\r", " ", "!", "\"", "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", ":", ";", "<", "=", ">", "?", "@", "[", "\\", "]", "^", "_", "`", "{", "|", "}", "~" ] >|	< #PARAMS :		(			< SPACE >		|	< CHAR >		|	< SPECIAL_SYMBOL >		)* >|	< #TABLE_BEGIN : "{|" (< PARAMS >)? >|	< #TABLE_END : "|}" >|	< #TABLE_CAPTION : "|+" (< PARAMS >)? >|	< #TABLE_ROW : "|-" (< PARAMS >)? >|	< #TABLE_CELL :		(			"||"		|	"!!"		) >|	< #TABLE_CELL_NL :		(			"|"		|	"!"		) >|	< #HORLINE : "---" ("-")+ >|	< #HEADER : ("=")		{			1, 6		}		>|	< #LI_SYMBOL : [ "*", "#", ":", ";" ] >|	< #LI : (< LI_SYMBOL >)+ (< SPACE >)* >|	<#ALPHA_CHAR: ["a"-"z", "A"-"Z"] >| 	<#NUM_CHAR:   ["0"-"9"] >|	<#ALPHANUM_CHAR: [ "a"-"z", "A"-"Z", "0"-"9" ] >|	<#IDENTIFIER_CHAR: [ "a"-"z", "A"-"Z", "0"-"9", "_", "-", ".", ":", ";","=", "\"", "'" ] >|	<#IDENTIFIER: <ALPHA_CHAR> (<IDENTIFIER_CHAR>)* >}< DEFAULT >TOKEN :{	// =========================================================================
	// URI syntax recognition.
	// =========================================================================
	// This grammar recognize the full URI syntax with following exceptions:
	//  * It has a simplified hier-part definition: it does not contain an empty 
	//    path (so the sequences like "here: " are not recognized as URIs).
	//  * It has a simplified version of the host definition: it does not contain
	//    explicit IP definitions. 
	//  * It parses "extended" URI syntax where "opaque" URIs are treated as 
	//    having multiple schema parts
	//    Example: in an opaque URI like "download:http://www.foo.com/bar.zip"
	//    the part "download:http" is treated as a "composite" scheme part.
	//
	// See also:
	//  * http://tools.ietf.org/html/rfc3986#page-49 - the official URI grammar
	//  * http://en.wikipedia.org/wiki/Uniform_Resource_Identifier
	//  * http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax
	//  * http://www.iana.org/assignments/uri-schemes.html
	// =========================================================================
	< URI : < URI_SCHEME_COMPOSITE > ":" < URI_HIER_PART > ("?" < URI_QUERY >)? ("#" < URI_FRAGMENT >)? >|	< #ALPHA : ([ "A"-"Z", "a"-"z" ]) >|	< #DIGIT : [ "0"-"9" ] >|	< #HEXDIG :		(			< DIGIT >		|	[ "A"-"F" ]		|	[ "a"-"f" ]		) >|	< #URI_GEN_DELIMS : [ ":", "/", "?", "#", "[", "]", "@" ] >	// Some default can not be accepted in the text - like "," symbols 
	//<#URI_SUB_DELIMS: [ "!", "$", "&", "'", "(", ")", "*", "+", ",", ";", "=" ]>
|	< #URI_SUB_DELIMS : [ "!", "$", "&", "'", "(", ")", "*", "+", /*",",*/";", "=" ] >|	< #URI_UNRESERVED :		(			< ALPHA >		|	< DIGIT >		|	"-"		|	"."		|	"_"		|	"~"		) >|	< #URI_RESERVED :		(			< URI_GEN_DELIMS >		|	< URI_SUB_DELIMS >		) >|	< #URI_SCHEME :		< ALPHA >		(			< ALPHA >		|	< DIGIT >		|	"+"		|	"-"		|	"."		)* >|	< #URI_SCHEME_COMPOSITE : < URI_SCHEME > (":" < URI_SCHEME >)* >|	< #URI_PCT_ENCODED : "%" < HEXDIG > < HEXDIG > >|	< #URI_PCHAR_FIRST :		(			< URI_UNRESERVED >		|	< URI_PCT_ENCODED >		|	< URI_SUB_DELIMS >		) >|	< #URI_PCHAR :		(			< URI_PCHAR_FIRST >		|	":"		|	"@"		) >|	< #URI_QUERY :		(			< URI_PCHAR >		|	"/"		|	"?"		)* >|	< #URI_FRAGMENT :		(			< URI_PCHAR >		|	"/"		|	"?"		)* >	// A simplified hier-part definition: it does not contain an empty path.
|	< #URI_HIER_PART :		(			"//" < URI_AUTHORITY > < URI_PATH_ABEMPTY >		|	< URI_PATH_ABSOLUTE >		|	< URI_PATH_ROOTLESS >		) >|	< #URI_AUTHORITY : (< URI_USERINFO > "@")? < URI_HOST > (":" < URI_PORT >)? >|	< #URI_USERINFO :		(			< URI_UNRESERVED >		|	< URI_PCT_ENCODED >		|	< URI_SUB_DELIMS >		|	":"		)* >|	< #URI_PATH_ABEMPTY : ("/" < URI_SEGMENT >)* >|	< #URI_PATH_ABSOLUTE :		"/"		(			< URI_SEGMENT_NZ > ("/" < URI_SEGMENT >)*		)? >|	< #URI_PATH_ROOTLESS : < URI_PCHAR_FIRST > < URI_SEGMENT_NZ_NC > ("/" < URI_SEGMENT >)* >|	< #URI_SEGMENT : (< URI_PCHAR >)* >|	< #URI_SEGMENT_NZ : (< URI_PCHAR >)+ >|	< #URI_SEGMENT_NZ_NC :		(			< URI_UNRESERVED >		|	< URI_PCT_ENCODED >		|	< URI_SUB_DELIMS >		|	"@"		)+ >|	< #URI_PORT : (< DIGIT >)+ >	// A simplified version of the host: it does not contain explicit IP definitions
|	< #URI_HOST : (< URI_REG_NAME >) >|	< #URI_REG_NAME :		(			< URI_UNRESERVED >		|	< URI_PCT_ENCODED >		|	< URI_SUB_DELIMS >		)* >	// =========================================================================
}< INITIAL_CONTEXT >TOKEN :{	< I_TABLE_BEGIN : (< NEW_LINE >)? < TABLE_BEGIN > > : DEFAULT|	< I_TABLE_END : (< NEW_LINE >)? < TABLE_END > > : DEFAULT|	< I_TABLE_CAPTION : (< NEW_LINE >)? < TABLE_CAPTION > > : DEFAULT|	< I_TABLE_ROW : (< NEW_LINE >)? < TABLE_ROW > > : DEFAULT|	< I_TABLE_CELL : < TABLE_CELL > > : DEFAULT|	< I_TABLE_CELL_NL : (< NEW_LINE >)? < TABLE_CELL_NL > > : DEFAULT|	< I_LIST_ITEM : (< NEW_LINE >)? < LI > > : DEFAULT|	< I_HEADER_BEGIN : (< NEW_LINE >)? < HEADER > (< SPACE >)* > : DEFAULT|	< I_HORLINE : (< NEW_LINE >)? < HORLINE > > : DEFAULT|	< I_HEADER_END : < HEADER > > : DEFAULT}< DEFAULT >TOKEN :{	< D_TABLE_BEGIN : < NEW_LINE > < TABLE_BEGIN > > : DEFAULT|	< D_TABLE_END : < NEW_LINE > < TABLE_END > > : DEFAULT|	< D_TABLE_CAPTION : < NEW_LINE > < TABLE_CAPTION > > : DEFAULT|	< D_TABLE_ROW : < NEW_LINE > < TABLE_ROW > > : DEFAULT|	< D_TABLE_CELL : < TABLE_CELL > > : DEFAULT|	< D_TABLE_CELL_NL : < NEW_LINE > < TABLE_CELL_NL > > : DEFAULT|	< D_LIST_ITEM : < NEW_LINE > < LI > > : DEFAULT|	< D_HEADER_BEGIN : < NEW_LINE > < HEADER > (< SPACE >)* > : DEFAULT|	< D_HORLINE : < NEW_LINE > < HORLINE > > : DEFAULT|	< D_HEADER_END : < HEADER > > : DEFAULT}< IMAGE >TOKEN :{	< IMAGE_ATTR :		"|"		(			"alt"(~["|","]"])*		|	"frameless"(~["|", "]"])*		|	"frame"(~["|", "]"])*		|	"thumb"(~["|", "]"])*		|	"right"(~["|", "]"])*		|	"left"(~["|", "]"])*		|	"center"(~["|", "]"])*		|	"none"(~["|", "]"])*		|	"upright"(~["|", "]"])*		|	([ "0"-"9" ])* ("x")? ([ "0"-"9" ])+ "px"		|	"link"(~["|","]"])*		) >	: IMAGE|	< IMAGE_CAPTION_BEGIN : "|" > : DEFAULT|   < IMAGE_WORD :		(			(				(					< CHAR >				|	"."				|	"-"				)*				< CHAR >			)		|	(< CHAR > ".")+		) > : DEFAULT| 	< IMAGE_NL: < NEW_LINE > > : DEFAULT |	< IMAGE_END : "]]" > : DEFAULT}< INITIAL_CONTEXT, DEFAULT >TOKEN :{	< IMAGE_BEGIN :		"[["		(			(				(					"I"				|	"i"				)				"mage:"			)		|			(				(					"F"				|	"f"				)				"ile:"			)		)		(			"\\" ~[ ]		|	~[ "]", "|" ]		)* >	: IMAGE|	< TEMPLATE_BEGIN : "{{" (~[ "}", "|" ])* > : DEFAULT|	< TEMPLATE_END : "}}" > : DEFAULT|	< SPACES : (< SPACE >)+ > : DEFAULT|	< WORD :		(			(				(					< CHAR >				|	"."				|	"-"				)*				< CHAR >			)		|	(< CHAR > ".")+		) >	: DEFAULT|	< SYMBOL : < SPECIAL_SYMBOL > > : DEFAULT|	< NL : < NEW_LINE > > : DEFAULT|	< REF_EMPTY : "<ref" (~[ "/" ])* "/>" > : DEFAULT|	< REF_BEGIN : "<ref" (~[ ">" ])* ">" > : DEFAULT|	< REF_END : "</ref>" > : DEFAULT|	< TAG_EMPTY : "<" < IDENTIFIER > (< IDENTIFIER > | < SPACE >)* "/>" > : DEFAULT|	< TAG_BEGIN : "<" < IDENTIFIER > (< IDENTIFIER > | < SPACE >)* ">" > : DEFAULT|	< TAG_END : "</" < IDENTIFIER > (< IDENTIFIER > | < SPACE >)* ">" > : DEFAULT|	< BOLD : "'''" >|	< ITALIC : "''" >|	< INT_LINK_BEGIN : "[[" > {		prevLexState = curLexState;	} : INT_LINK|	< EXT_LINK_BEGIN : "[" >|   < HTML_ENTITY: "&" (<CHAR>){1,8} ";" >}< DEFAULT, INT_LINK >TOKEN :{	< EXT_LINK_END : "]" >	{		if (curLexState == MediawikiScannerConstants.INT_LINK)			SwitchTo(MediawikiScannerConstants.DEFAULT);	}}< INT_LINK >TOKEN :{	< INT_LINK_PREFIX :		(			(":")? (~[ "]", " ", "\t", "|" ])+ ":"		) >|	< INT_LINK_SEPARATOR : "|" >|	< INT_LINK_SPACES : (< SPACE > | < NL >)+ >|	< INT_LINK_END : ("]]") (< CHAR >)* >	{		SwitchTo(prevLexState);	}|	< INT_LINK_CONTENT :		(			(				(					< CHAR >				|	"."				|	"-"				)*				< CHAR >			)		|	(< CHAR > ".")+		) >|	< INT_LINK_SYMBOL :		< SPECIAL_SYMBOL >	|	"["	|	"]" >}Token getTABLE_BEGIN() :{	Token t = null;}{	(		t = < I_TABLE_BEGIN >	|	t = < D_TABLE_BEGIN >	)	{		return t;	}}Token getTABLE_END() :{	Token t = null;}{	(		t = < I_TABLE_END >	|	t = < D_TABLE_END >	)	{		return t;	}}Token getTABLE_CAPTION() :{	Token t = null;}{	(		t = < I_TABLE_CAPTION >	|	t = < D_TABLE_CAPTION >	)	{		return t;	}}Token getTABLE_ROW() :{	Token t = null;}{	(		t = < I_TABLE_ROW >	|	t = < D_TABLE_ROW >	)	{		return t;	}}Token getTABLE_CELL() :{	Token t = null;}{	(		t = < I_TABLE_CELL >	|	t = < D_TABLE_CELL >	)	{		return t;	}}Token getTABLE_CELL_NL() :{	Token t = null;}{	(		t = < I_TABLE_CELL_NL >	|	t = < D_TABLE_CELL_NL >	)	{		return t;	}}Token getLIST_ITEM() :{	Token t = null;}{	(		t = < I_LIST_ITEM >	|	t = < D_LIST_ITEM >	)	{		return t;	}}Token getHEADER_BEGIN() :{	Token t = null;}{	(		t = < I_HEADER_BEGIN >	|	t = < D_HEADER_BEGIN >	)	{		return t;	}}Token getHORLINE() :{	Token t = null;}{	(		t = < I_HORLINE >	|	t = < D_HORLINE >	)	{		return t;	}}Token getHEADER_END() :{	Token t = null;}{	(		t = < I_HEADER_END >	|	t = < D_HEADER_END >	)	{		return t;	}}Token symbol() :{	Token t;}{	(		t = < SYMBOL >	|	t = < EXT_LINK_BEGIN >	|	t = < EXT_LINK_END >	)	{		return t;	}}void doParse() :{	token_source.SwitchTo(token_source.INITIAL_CONTEXT);}{	(		contents()	)*	< EOF >}void contents() :{	Token t;	WikiToken tt;}{	LOOKAHEAD(table())	table()|	content()|	(		t = getTABLE_BEGIN()	|	t = getTABLE_CAPTION()	|	t = getTABLE_ROW()	|	t = getTABLE_CELL()	|	t = getTABLE_CELL_NL()	|	t = getTABLE_END()	|   t = < INT_LINK_SYMBOL >	|   t = < INT_LINK_SEPARATOR >	)	{		tt = new WikiToken(MediawikiScannerConstants.SYMBOL, new String(t.image));		tokens.add(tt);	}	|   t = < INT_LINK_SPACES >	{		tt = new WikiToken(MediawikiScannerConstants.SPACES, new String(t.image));		tokens.add(tt);	}}void content() :{	Token t;	WikiToken tt;}{	(		image()	|	template()	|	LOOKAHEAD(intLink())		intLink()	|	LOOKAHEAD(extLink())		extLink()	|	LOOKAHEAD(header())		header()	|	line()	|		(			t = < EXT_LINK_BEGIN >		|	t = < EXT_LINK_END >		|	t = < INT_LINK_BEGIN >		|	t = < INT_LINK_PREFIX >		|	t = < INT_LINK_CONTENT >		|	t = getHEADER_BEGIN()		|	t = getHEADER_END()		)		{			char[] symArray = t.image.trim().toCharArray();			for (int i = 0; i < symArray.length; i++)			{				tt = new WikiToken(MediawikiScannerConstants.SYMBOL, new String(Character.toString(symArray [ i ])));				tokens.add(tt);			}		}	)}void line() :{	Token t;	WikiToken tt;}{	t = getHORLINE()	{		tt = new WikiToken(t.kind, new String(t.image.trim()), t.image);		tokens.add(tt);	}|	t = getLIST_ITEM()	{		tt = new WikiToken(t.kind, new String(t.image.trim()), t.image);		tokens.add(tt);	}|	t = < BOLD >	{		tokens.add(new WikiToken(t));	}|	t = < ITALIC >	{		tokens.add(new WikiToken(t));	}|	(		t = < WORD >	|   t = < HTML_ENTITY >	|	t = < URI >	|	t = < SYMBOL >	)	{		tokens.add(new WikiToken(t));	}	|	t = < SPACES >	{		if (tokens.size() > 0)		{			tt = tokens.get(tokens.size() - 1);			tt.displayString += t.image;			tokens.set(tokens.size() - 1, tt);		}	}		|		(			t = < REF_EMPTY >		|	t = < REF_BEGIN >		|	t = < REF_END >		|	t = < TAG_EMPTY >		|	t = < TAG_BEGIN >		|	t = < TAG_END >		)		{			tokens.add(new WikiToken(t));		}|	t = < NL >	{		if (tokens.size() > 0)		{			tt = tokens.get(tokens.size() - 1);			if (tt.kind == MediawikiScannerConstants.NL)			{				tt.displayString += t.image;				tokens.set(tokens.size() - 1, tt);			}			else				tokens.add(new WikiToken(t));		}		else			tokens.add(new WikiToken(t));	}}void template() :{	Token t;}{	t = < TEMPLATE_BEGIN >	{		tokens.add(new WikiToken(t));	}|	t = < TEMPLATE_END >	{		tokens.add(new WikiToken(t));	}}void image() :{	Token t;	WikiToken tt;	String str;	int prefixLen;}{	t = < IMAGE_BEGIN >	{		if (t.image.toLowerCase().startsWith("[[image:")) prefixLen = 8;		else prefixLen = 7;		tt = new WikiToken(t.kind, new String(t.image.substring(prefixLen)), t.image);		tokens.add(tt);	}	(		t = < IMAGE_ATTR >		{			tt = new WikiToken(t.kind, new String(t.image.substring(1)), t.image);			tokens.add(tt);		}	|   t = < IMAGE_CAPTION_BEGIN >	{		tokens.add(new WikiToken(t));	}	| 	t = < IMAGE_WORD >	{		tokens.add(new WikiToken(MediawikiScannerConstants.WORD, new String(t.image)));	}	| 	t = < IMAGE_NL >	{		tokens.add(new WikiToken(MediawikiScannerConstants.NL, new String(t.image)));	}	)*	(		LOOKAHEAD(3) (			< IMAGE_END > |			( < EXT_LINK_END > < EXT_LINK_END > )		)		{			tokens.add(new WikiToken(MediawikiScannerConstants.IMAGE_END, new String("]]")));		}	|		(		  LOOKAHEAD(2) content()		)*	)}void intLink() :{	Token t;	WikiToken tt, colon;	boolean prefixed = false;}{	t = < INT_LINK_BEGIN >	{		tokens.add(new WikiToken(t));	}	(		t = < INT_LINK_PREFIX >		{			if (!prefixed)			{				tokens.add(new WikiToken(t));				prefixed = true;			}			else			{				tt = new WikiToken(MediawikiScannerConstants.WORD, new String(t.image.replace(':', ' ').trim()));				tokens.add(tt);				colon = new WikiToken(MediawikiScannerConstants.SYMBOL, new String(":"));				tokens.add(colon);			}		}	|	t = < INT_LINK_CONTENT >		{			prefixed = true;			tt = new WikiToken(MediawikiScannerConstants.WORD, new String(t.image));			tokens.add(tt);		}	|	t = < INT_LINK_SYMBOL >		{			prefixed = true;			tt = new WikiToken(MediawikiScannerConstants.SYMBOL, new String(t.image));			tokens.add(tt);		}	|	t = < INT_LINK_SPACES >		{			prefixed = true;			tt = tokens.get(tokens.size() - 1);			tt.displayString += t.image;			tokens.set(tokens.size() - 1, tt);		}	|	t = < INT_LINK_SEPARATOR >		{			prefixed = true;			tokens.add(new WikiToken(t));		}	)*	(	  t = < INT_LINK_END >	{		tokens.add(new WikiToken(t));	}	/* FIXME: How to deal with unbalanced tags? */	| t = < EXT_LINK_END >	{		tokens.add(new WikiToken(MediawikiScannerConstants.INT_LINK_END, new String(t.image)));	}	)}void extLink() :{	Token t;	WikiToken tt;}{	t = < EXT_LINK_BEGIN >	{		tokens.add(new WikiToken(t));	}	t = < URI >	{		tokens.add(new WikiToken(t));	}	(		line()	|		(			t = < EXT_LINK_BEGIN >		|	t = < INT_LINK_BEGIN >		)		{			tt = new WikiToken(MediawikiScannerConstants.SYMBOL, new String(t.image));			tokens.add(tt);		}	)*	t = < EXT_LINK_END >	{		tokens.add(new WikiToken(t));	}}void table() :{	Token t = null;}{	t = getTABLE_BEGIN()	{		tokens.add(new WikiToken(t));	}	(		t = getTABLE_CAPTION()		{			tokens.add(new WikiToken(t));		}	)?	(		tableRow()	|	t = getTABLE_ROW()		{			tokens.add(new WikiToken(t));		}	)+	t = getTABLE_END()	{		tokens.add(new WikiToken(t));	}}void tableRow() :{	Token t = null;}{	(		t = getTABLE_CELL_NL()	)	{		String str = t.image.trim();		boolean head = str.startsWith("!");		tokens.add(new WikiToken(t, t.image));	}	(		LOOKAHEAD(table())		table()	|	t = getTABLE_CELL()		{			tokens.add(new WikiToken(t));		}	|	content()	)*}void header() :{	Token t;	WikiToken tt;}{	t = getHEADER_BEGIN()	{		tt = new WikiToken(t.kind, new String(t.image.trim()), t.image);		tokens.add(tt);	}	(		line()	)+	t = getHEADER_END()	{		tt = new WikiToken(t.kind, new String(t.image.trim()), t.image);		tokens.add(tt);	}}